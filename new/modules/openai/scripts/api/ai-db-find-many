#!/usr/bin/env sh

# NAME 
#  ai-db-find-many - Find all or multiple records for a given table
#
# SYNOPSIS
#  ai-db-find-many <-t table_name> [-w where_clause] [-f filter_clause]
#
# DESCRIPTION
#  Find many records in a table by providing a sqlite WHERE clause. By default
#  all fields are included and can be filtered by providing a -f|--filter flag.
#
#  Return an empty array if no records are found or an array of records as JSON.
#
# OPTIONS
#  -t, --table <table_name>
#   The table to query.
#
#  -f, --filter [filter_clause]
#   The filter clause to use when querying the database. Defaults to "*".
#
#  -w, --where [where_clause]
#   The WHERE clause to use when querying the database.
#
#  -i, --include [related_tables]
#   A comma separated list of related tables to include in the query.
#   All fields from the related tables will be included in the result.
#
# ERROR CODES
#  1 Input error: unknown flag provided, missing value for flag or missing
#    required flag
#
# ENVIRONMENT
#  OPENAI_DB_FILE
#   The SQLite database file.
#
# EXAMPLES
#  ai-db-find-many -t users
#   Find all users and return all fields.
#
#  ai-db-find-many -t users -w "type = 'admin'" -f "id, name"
#   Find all users where type is admin and only return the id and name fields.
#
#  ai-db-find-many -t users -i "Posts,Comments"
#   Find all users and include all posts and comments for each user.
#
# SEE ALSO
#  sqlite3(1)

FILTER="*"
WHERE=""
MAIN_TABLE=""
RELATED=""

validate_flag() {
  if [ -z "$2" ] || [ "${2#-}" != "$2" ]; then
    echo "error: argument $1 requires a value" >&2
    exit 1
  fi
}

parse_flags() {
  while [ "$#" -gt 0 ]; do
    case $1 in
      -f|--filter)
        validate_flag "$1" "$2"
        FILTER=$2; shift
        ;;
      -w|--where)
        validate_flag "$1" "$2"
        WHERE=$2; shift
        ;;
      -t|--table)
        validate_flag "$1" "$2"
        MAIN_TABLE=$2; shift
        ;;
      -i|--include)
        validate_flag "$1" "$2"
        RELATED=$2; shift
        ;;
      --) shift; break ;;
      -?*) echo "error: unknown flag $1" >&2; exit 1 ;;
      *) break ;;
    esac
    shift
  done
}

query_database() {
  query="SELECT $FILTER FROM $MAIN_TABLE"
  
  if [ -n "$WHERE" ] ; then
    query="$query WHERE $WHERE"
  fi

  sqlite3 --json "$OPENAI_DB_FILE" "$query"
}

# 1:1 or N:1 relationships
attach_direct_relationships() {
  related_table="$1"
  related_table_lower="$2"

  # Fetch all related items in one query, for all main items to reduce the 
  # impact of N+1 queries
  related_items=$(sqlite3 --json "$OPENAI_DB_FILE" \
    "SELECT * FROM $related_table WHERE id IN ( \
      SELECT ${related_table_lower}_id FROM $main_table_lower WHERE id IN ($main_items_ids) \
    )"
  )

  # Attach related items, only those matching the ids from the main items
  MAIN_ITEMS=$(jq --null-input --compact-output \
    --argjson main_items "$MAIN_ITEMS" \
    --argjson related_items "$related_items" \
    '$main_items | map((. as $item | . + { 
      '"$related_table"': (
        $related_items | map(select(.id == $item.'"${related_table_lower}_id"')) | .[0]
      ) 
    }))'
  )
}

# 1:N relationships
attach_inverse_relationships() {
  related_table="$1"
  related_table_lower="$2"

  # Fetch all related items in one query, for all main items to reduce the 
  # impact of N+1 queries
  related_items=$(sqlite3 --json "$OPENAI_DB_FILE" \
    "SELECT * FROM $related_table_lower WHERE ${MAIN_TABLE}_id IN ($main_items_ids)"
  )

  # Attach related items, only those matching the ids from the main items
  MAIN_ITEMS=$(jq --null-input --compact-output \
    --argjson main_items "$MAIN_ITEMS" \
    --argjson related_items "$related_items" \
    '$main_items | map((. as $item | . + { 
      '"$related_table"': (
        $related_items | map(select(.'"${main_table_lower}_id"' == $item.id))
      ) 
    }))'
  )
}

attach_related_models() {
  main_items_ids=$(echo "$MAIN_ITEMS" | jq '.[].id' | tr '\n' ',' | sed 's/,$//')
  main_table_lower=$(echo "$MAIN_TABLE" | tr '[:upper:]' '[:lower:]')

  # For each related table, query the database and add the related items to the 
  # main items using the related table name as the key.
  for related_table in $(echo "$RELATED" | tr ',' '\n'); do
    related_table_lower=$(echo "$related_table" | tr '[:upper:]' '[:lower:]')

    # 1:1 or N:1
    # For ex. if querying `Messages` and including `Users`, 
    # check for `Messages.user_id` 
    if ai-db-has-field -t "$MAIN_TABLE" -f "${related_table_lower}_id"; then
      attach_direct_relationships "$related_table" "$related_table_lower"
    fi

    # 1:N
    # For ex. if querying `Users` and including `Messages`,
    # check for `Messages.users_id`
    if ai-db-has-field -t "$related_table" -f "${main_table_lower}_id"; then
      attach_inverse_relationships "$related_table" "$related_table_lower"
    fi
  done
}

# Main
parse_flags "$@"

if [ -z "$MAIN_TABLE" ]; then
  echo "error: missing required flag -t|--table" >&2
  exit 1
fi

MAIN_ITEMS=$(query_database)

if [ -z "$MAIN_ITEMS" ]; then
  echo "[]"
  exit 0
fi

if [ -z "$RELATED" ]; then
  echo "$MAIN_ITEMS"
  exit 0
fi

attach_related_models

echo "$MAIN_ITEMS"
